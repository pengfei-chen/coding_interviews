

1；现给定任意正整数 n，请寻找并输出最小的正整数 m（m>9），使得 m 的各位（个位、十位、百位 ... ...）之乘积等于n，若不存在则输出 -1。

例子1：
输入 36，  输出 49
输入108，  输出 269

# 参考答案
def solution(n ):
    if n < 10:
        return 10 + n
    else:
        ans = ''
        for i in range(9,1,-1):
            while n % i == 0:
                n = n / i
                ans += str(i)
        if n > 1:
            return -1
        ans = ans[::-1]
        ans = int(ans)
        return ans

2；在美的产线上，每位职工随着对空调加工流程认识的熟悉和经验的增加，日产量也会不断攀升。
假设第一天量产1台，接下来2天(即第二、三天)每天量产2件，接下来3天(即第四、五、六天)每天量产3件 ... ... 
以此类推，请编程计算出第n天总共可以量产的空调数量。

输入例子1: 11
输出例子1: 35
例子说明1: 第11天工人总共可以量产的手机数量为35

# 参考答案
def solution(n ):
    # write code here
    ans = 0
    i = 1
    while n >= 1:
        if n > i:
            n -= i
            ans +=  i*i
            i += 1
        else:
            ans += n * i
            n = 0
return ans


3；比大小，给定一个整数数组，返回一个数组。该返回数组中第i个数字为，原数组中第i个位置的数字至少往右走多少步才能遇到比它大的数字。如果遇不到或者已经处于最右的位置，则置为-1。

输入描述:
输入为多行，第一行为一个整数N，1≤N≤106
接下来一共有N行，每一行为一个整数M，0≤M≤232-1
输出描述:
输出 N 行，每行一个数字表示转换之后的数组
输入例子1:
5
91
10
3
22
40

输出例子1:
-1
2
1
1
-1

参考答案1；
a = int(input())
lst = []
ans = []
for i in range(a):
    lst.append(int(input()))
length = len(lst)

for i in range(length-1):
    j = i + 1
    for j in range(j,len(lst)):
        if lst[i] >= lst[j]:
            j += 1
        else:
            ans.append(j-i)
            break
    if j == length:
        ans.append(-1)
ans.append(-1)
for k in ans:
print(k)

参考答案2；
思路：利用栈。如果数组block当前数大于栈顶数，则表明找到了栈顶数的右边第一个大于他的数，将下标相减，填入result数组即可。否则表明当前数还没有比他大的数，则将它入栈，继续遍历数组block下一个数，看看后面的数有没有大于他的。

num = int(input())
block, stack, result = [], [], []
for i in range(num):
    block.append(int(input()))
    result.append(-1)

i = 0
while (i < num):
    if (not (len(stack) == 0)) and (block[i] > block[stack[-1]]):
        cur = stack.pop()
        result[cur] = i - cur

    else:
        stack.append(i)
        i += 1

for i in range(len(result)):
    print(result[i])


4；寻找最后的山峰，山峰元素是指其值大于或等于左右相邻值的元素。给定一个输入数组nums，任意两个相邻元素值不相等，数组可能包含多个山峰。找到索引最大的那个山峰元素并返回其索引。假设 nums[-1] = nums[n] = -∞。
输入描述:
在命令行中输入一行数字，数字之间以空格分割，遇到换行符结束。输入的数字为整型，且总数量在10万以内。
输出描述:
输出索引最大的山峰的索引值（一个数字）
输入例子1:
2 4 1 2 7 8 4
输出例子1:
5
例子说明1:
索引最大的山峰的高度为8，其索引为5

参考答案：
nums = list(map(int,input().strip().split(' ')))
result = 0
i=len(nums)-1
while i>0:
    if nums[i]>=nums[i-1]:
        result = i
        break
    i-=1
print(str(result))

5；滑动窗口的中位数
在实时计算中，数据流源源不断地流入计算单元，经常需要借助窗口来处理数据，其中有一类窗口为滑动窗口（Sliding Window），其特点是窗口长度固定，每次滑动一定的位移（slide）
现给定一个数组 nums，有一个长度为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。注意你只可以看到在滑动窗口 k 内的数字，滑动位移大小slide=1，即滑动窗口每次只向右移动一位。
要求返回每一个滑动窗口内的中位数，中位数定义：按顺序排序的一组数据中居于中间位置的数，例如：对于[2,3,4]，中位数是3；对于[2,3]，中位数是 (2 + 3) / 2 = 2.5
（注意：为了简化窗口计算，规定如果没有累计到窗口大小的数，不能触发计算，即不输出结果！）
输入描述:
输入两个数字n，k。n表示数组长度，k表示窗口大小
加下来n个整数用空格隔开，表示nums数组
(1<=k<=n)
(1<=n<=1000)
输出描述:
输出若干个数字，表示滑窗依次移动得到的结果，保留小数点后一位数字
示例1
输入
8 3
1 3 -1 -3 5 3 6 7
输出
1.0 -1.0 -1.0 3.0 5.0 6.0


参考答案：
a,b = [int(i) for i in input().split()]
lst = [int(i) for i in input().split()]

# 求中位数
def get_median(use):
    use.sort()  # 中位数是一个排序好的数组的中间数
    if len(use) % 2 == 1:
        start = len(use) // 2
        end = start + 1
        ans = float(use[start:end][0])
    else:
        start = len(use) // 2
        end = start + 1
        use_1 = use[start-1:end]
        ans = round(float(sum(use_1)/2), 2)
    return ans

result = ''
for i in range(a-(b-1)):
    use = lst[i:i+b]
    ans = get_median(use)
    result += str(ans) + ' '
print(result)


6；月份天数
输入年份月份，请输出这个月的天数
（温馨提示：闰年为除以4为0，但不能是除以100为0的年数，或者是除以400为0的年数。）
输入描述:
多组输入输出
第一个参数为年份，如2018代表2018年，2019代表2019年
第二个参数为月份，如1代表1月，2代表2月
（参数间均以空格隔开）
输出描述:
输出当月的实际天数。
输入例子1:
2018 2
2020 2
2000 2
2019 1
1900 2
输出例子1:
28
29
29
31
28
参考答案：
def get_month_year(x, y):
    if y in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif y in [4, 6, 9 ,11]:
        return 30
    elif y == 2 and (x%4 == 0 and x%100 !=0) or x%400==0:
        return 29
    else:
        return 28
# 注意，这里是循环输入ACM模式
while True:
    try:
        year, month = map(int,input().split())
        print(get_month_year(year, month))
    except:
        break;

7；整数分解
一个正整数N可以分解为M(M>1)个正整数的和，即N=K+L，例如N=5、M=2时可以分解为(1+4,2+3)。
给定一个正整数N(1<N<200)及正整数M(1<M<200)，求有多少种可能的分解组合(注：K+L和L+K算一种)
输入描述:
输入两个数N和M
输出描述:
可以分解的组合数。
输入例子1:
5,2
输出例子1:
2 
（分解成2个数的和，2种输出：1,4、 2,3）
输入例子2:
6,3
输出例子2:
3
（分解成3个数的和，3种输出：1,1,4、 1,2,3、 2,2,2）

参考答案：
N, K = [int(x) for x in input().split(',')]

def Data(N,k): #k拆分
    if N<k:
        return 0 #此时无法划分
    else:
        if k==1:
            return 1
        else:
            D={}
            D[0,0]=0
            for i in range(1,N+1):
                for j in range(1,min(i+1,k+1)):
                    if j==1:
                        D[i,j]=1
                    else:    #这里的状态转移方程有点难想明白，思路如下
                        D[i,j]=D[i-1,j-1]   
                        if i>=2*j:        
                            D[i,j]+=D[i-j,j]
            return D[N,k]
print(Data(N,K))

总的问题可以理解成 N个球，放进K个框，每个框至少有一个球。
PS：状态转移方程说明。
假设现在输入：i=8，j=3
一共有5种划分方式
1，1，6
1，2，5
1，3，4
2，2，4
2，3，3

如果i >= 2 * j 不成立，则肯定有一个“框”里面放的“球”个数是1，那么先挑一个框，放1个球，然后再D[i-1, j-1]种放法。  也就是对应上面 5行数据种的前三行。

当 i >= 2*j 成立时，除了有 “一个框只有一个球”的情况，还有每个框至少两个球的情况。这种情况的实现思路是，先对 i 个球，每个 框 先放一个，还余下 i-j 个球。而余下的i-j个球是 大于等于 j 的，所以再 调用D[ i – j, j]（即每个框至少还放一个球，加上之前一个，则至少有两个球了，以此递推）。

综上，当i >= 2 * j 不成立，只用考虑第一种情况；当i >= 2 * j 成立，还要加上每个框至少两个的情况（往后更复杂的情况，因为直接使用离它最近的结果，也能实现；比如每个框至少3个，4个等情况。）


8；数组中的重复数字
题目描述
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1

示例：
输入：[2,3,1,0,2,5,3]
输出：2 或 3

参考答案：
//解题思路
    /*替换法（O(n),O(1)）
    数组存放原则：numbers[i] = i
    遍历数组所有元素，交换不符合数组存放原则的元素：
        例如[2,3,1,0,2]
        遍历0位元素2：（交换0位元素2和2位元素1）->[1,3,2,0,2]
        遍历0位元素1：（交换0位元素1和1位元素3）->[3,1,2,0,2]
        遍历0位元素3：（交换0位元素3和3位元素0）->[0,1,2,3,2]
        依次遍历0、1、2、3位置元素，都符合存放原则numbers[i] = i，不做任何操作
        遍历末位元素2，此时末位元素2和2位元素2相等，出现了两次，即数字2位重复元素
     */

python中，for循环不能改变其中 i 的值。
调通的python版本代码如下。

class Solution:
    def duplicate(self , numbers ):
        # write code here
        i = 0
        length = len(numbers)
        while i < length:
            if numbers[i] != i:
                if numbers[i] == numbers[numbers[i]]:
                    return numbers[i]
                temp = numbers[numbers[i]]
                numbers[numbers[i]] = numbers[i]
                numbers[i] = temp
                i -= 1
            i += 1
        return -1






9；二维数组中的查找

题目描述
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[
  [1,2,8,9],
  [2,4,9,12],
  [4,7,10,13],
  [6,8,11,15]
]
给定 target = 7，返回 true。
给定 target = 3，返回 false。

示例1：
输入：7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
输出：true
说明：存在7，返回true

示例2：
输入：3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
输出：false
不存在3，返回false

参考答案：

# -*- coding:utf-8 -*-
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        if len(array[0]) == 0:
            return False
        row = len(array)
        col = len(array[0])
        xrow = row - 1   #初始行
        xcol = 0   #初始列
        while xrow > -1 and xcol <col:
            x = array[xrow][xcol]
            if x == target:
                return True
            elif x > target:
                xrow -= 1
            elif x < target:
                xcol += 1
        return False


10；从尾到头打印链表

题目描述
输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

示例1

输入：{67,0,24,58}
输出：[58,24,0,67]

参考答案：

# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        lst = []
        while listNode:
            lst.insert(0,listNode.val)
            listNode = listNode.next   # 清楚链表的数据结构，这题就送分
        return lst




11；重建二叉树

题目描述
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

示例1
输入：[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]
输出：{1,2,5,3,4,6,7}

参考答案：

# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        if len(pre)==0:
            return None
        root = TreeNode(pre[0])
        index = tin.index(root.val)
        leftNum = index   # 左边节点的数量，其实这里是 index - 0
        rightNum = len(tin) - leftNum - 1   #  -1 是去除中序遍历的 根节点
        root.left = self.reConstructBinaryTree(pre[1:1+leftNum],tin[0:leftNum])   # 根节点的左子树的，前序遍历 中序遍历  直接递归调用
        root.right = self.reConstructBinaryTree(pre[1+leftNum:],tin[leftNum+1:])  # 根节点的右子树的，前序遍历 中序遍历
        return root


12；二叉树的下一个结点

题目描述
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

参考答案：

# -*- coding:utf-8 -*-
# class TreeLinkNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#         self.next = None  #指向其父节点
class Solution:
    def GetNext(self, pNode):
        # write code here
        if pNode == None:
            return None
        if pNode.right != None:  #如果当前节点有右子节点，下一节点是这个右节点最左边的节点
            pNode = pNode.right
            while pNode.left != None:  # 只要其子树还有左子节点，找到最后一个为止
                pNode = pNode.left
            return pNode   #如果右子节点没有左子节点，直接返回其右子节点
        while pNode.next != None: # 此时，当前节点没有右节点，考虑其父节点，以及其父节点的父节点，如果有父节点
            if pNode.next.left == pNode:  #如果当前节点位于其父节点的左边。这里表示其父节点的左子节点就是当前节点
                return pNode.next   # 直接返当前节点的父节点即可
            pNode = pNode.next   #如果当前节点位于其父节点的右边。替换状态，用父节点取代当前查询的原节点，继续迭代这个while循环。
        return None


13；用两个栈实现队列

题目描述
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

参考答案：

# -*- coding:utf-8 -*-
class Solution:
    stack1 = []
    stack2 = []
    #列表的append,pop()不指定就是一个栈
    def push(self, node):
        # write code here
        self.stack1.append(node)
    def pop(self):
        # return xx
        if len(self.stack2) == 0:
            while len(self.stack1) != 0:
                self.stack2.append(self.stack1[-1])  # 取出stack1的最后一个填入
                # 这里最先进入stack1的，最后才进入stack2,所以位于stack2的最后面
                self.stack1.pop()  #去掉stack1的最后一个元素
        xx = self.stack2[-1] #队列先进先出，
        self.stack2.pop()
        return xx


14；跳台阶

Tag：递归

题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

参考答案：

# -*- coding:utf-8 -*-
class Solution:
    def jumpFloor(self, number):
        # write code here
        if number <= 2:
            return number
        f1 = 1
        f2 = 2
        for i in range(3,number+1):
            f = f1 + f2
            f1 = f2
            f2 = f 
        return f


15；变态跳台阶

Tag：动态规划

题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

示例1
输入：3
输出：4

参考答案：（DP动态规划）

# -*- coding:utf-8 -*-
class Solution:
    def jumpFloorII(self, number):
        # write code here
        #设到每一层有x种方法，然后每一层到第n层，都可以直接到达，因此
        dp = [0,1,2]
        for i in range(3,number+1):
            dp.append(sum(dp) + 1)
        return dp[number]


16；斐波那契数列

题目描述
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n≤39

参考答案：

# -*- coding:utf-8 -*-
class Solution:
    def Fibonacci(self, n):
        # write code here
        if n <= 1:
            return n
        f1 = 0
        f2 = 1
        for i in range(2,n+1):
            f = f1 + f2
            f1 = f2
            f2 = f 
        return f


17；矩形覆盖

题目描述
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

比如n=3时，2*3的矩形块有3种覆盖方法：
 

分析： 
依旧是斐波那契数列 
2*n的大矩形，和n个2*1的小矩形 
其中target*2为大矩阵的大小 
有以下几种情形： 
1；target <= 0 大矩形为<= 2*0,直接return 1； 
2；target = 1大矩形为2*1，只有一种摆放方法，return1； 
3；target = 2 大矩形为2*2，有两种摆放方法，return2； 
4；target = n 分为两步考虑： 
        第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(target - 1)
     第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def rectCover(self, number):
        # write code here
        ans = [0,1,2]
        for i in range(3,number+1):
            res = ans[i-2] + ans[i-1]
            ans.append(res)
        return ans[number]

18；旋转数组的最小数字
Type：二分法

题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

输入：[3,4,5,1,2]
输出：1


参考答案：

# -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        # write code here
        if len(rotateArray) == 0:
            return 0
        left = 0
        right = len(rotateArray) - 1
        while left < right:
            mid = left + (right - left) // 2
            if rotateArray[right] < rotateArray[mid]:
                left = mid + 1
            elif rotateArray[right] == rotateArray[mid]:
                left += 1
            else:
                right = mid
                
        return rotateArray[left]










19；矩阵中的路径
Type：DFS
 
参考答案：

class Solution:
    def hasPath(self , matrix , word ):
        # write code here
        def dfs(i, j, k):
            """路径是否存在"""
            if not 0 <= i < len(matrix) or not 0 <= j < len(matrix[0]) or matrix[i][j] != word[k]:
                return False
            if len(word) - 1 == k:
                return True
            matrix[i][j] = ""   #标记已经使用该点
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j - 1, k + 1) or dfs(i, j + 1, k + 1)
            matrix[i][j] = word[k]   #复原该点的标记
            return res
        # 遍历入口
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dfs(i, j, k = 0): return True
        return False


20；机器人的运动范围
题目描述：地上有一个rows行和cols列的方格。坐标从 [0,0] 到 [rows-1,cols-1]。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于threshold的格子。 例如，当threshold为18时，机器人能够进入方格[35,37]，因为3+5+3+7 = 18。但是，它不能进入方格[35,38]，因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

范围:
1 <= rows, cols<= 100
0 <= threshold <= 20

示例：
输入：1,2,3
返回值：3

输入：0,1,3
返回值：1

参考答案：
# -*- coding:utf-8 -*-
import copy
class Solution:
    def explore(self,row,col):
        if not (row>=0 and row <self.row and col >=0 and col < self.col):
            return
        row_to_lst = list(map(int, list(str(row))))
        col_to_lst = list(map(int, list(str(col))))
        if sum(row_to_lst) + sum(col_to_lst) > self.threshold:
            return
        if self.visit_tag[row][col] == 1:
            return 
        self.ans += 1
        self.visit_tag[row][col] = 1
        self.explore(row,col-1)
        self.explore(row,col+1)
        self.explore(row-1,col)
        self.explore(row+1,col)
        
    def movingCount(self, threshold, rows, cols):
        # write code here
        self.row = rows
        self.col = cols
        self.threshold = threshold
        self.visit_tag = [[0]*cols for i in range(rows)]
        self.ans = 0
        self.explore(0,0)
        return self.ans

21；二进制中1的个数
输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def NumberOf1(self, n):
        # write code here
        count = 0
        if n < 0:
            n = n & 0xffffffff
        while n:
            count += 1
            n = (n - 1) & n   # 将原 n 二进制中 最右边的 1 变为 0
        return count


22；数值的整数次方
题目描述
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def Power(self, base, exponent):
        # write code here
        return base**exponent

（主要是这也不算是库函数。。）

23；删除链表中重复的结点

题目描述
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
示例：
输入：{1,2,3,3,4,4,5}
输出：{1,2,5}

参考答案：
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def deleteDuplication(self, pHead):
        # write code here
        dummy = ListNode(0)  #新引入一个节点，作为当前首节点的前节点
        dummy.next = pHead
        prev = dummy
        cur = pHead
        while (cur is not None):
            if cur.next is not None and cur.next.val == cur.val:
                val = cur.val
                while (cur is not None and cur.val==val):  # 多个相同值连在一起
                    del_node = cur
                    prev.next = cur.next # 改变前指针的指向
                    cur = cur.next
                    del del_node
            else:
                prev = prev.next
                cur = cur.next
        return dummy.next


24；调整数组顺序使奇数位于偶数前面

题目描述
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

示例：
输入：[1,2,3,4]
输出：[1,3,2,4]
参考答案：
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
# @param array int整型一维数组 
# @return int整型一维数组

class Solution:
    def reOrderArray(self , array ):
        # write code here
        lst_1 = []
        lst_2 = []
        for i in array:
            if i % 2 == 0:
                lst_2.append(i)
            else:
                lst_1.append(i)
        lst_1.extend(lst_2)
        return lst_1


25；链表中倒数第k个结点
题目描述
输入一个链表，输出该链表中倒数第k个结点。
如果该链表长度小于k，请返回空。

输入：{1,2,3,4,5},1 
输出：{5}

参考答案：
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
# @param pHead ListNode类 
# @param k int整型 
# @return ListNode类
#
class Solution:
    def FindKthToTail(self , pHead , k ):
        # write code here
        if pHead == None  or k<1:
            return None
        p = pHead
        q = pHead
        step = 1
        while p.next is not None:
            if step >= k and q is not None:
                q = q.next
            p = p.next
            step += 1
        if k <= step:
            return q
        else:
            return None


26；链表中环的入口结点

题目描述
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

参考答案：
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
"""
设置快慢指针，都从链表头出发，快指针每次走两步，慢指针一次走一步，
假如有环，一定相遇于环中某点(结论1)。
接着让两个指针分别从相遇点和链表头出发，两者都改为每次走一步，最终相遇于环入口(结论2)。
"""
class Solution:
    def EntryNodeOfLoop(self, pHead):
        # write code here
        slow = pHead
        fast = pHead
        while(fast is not None and fast.next is not None):
            slow = slow.next
            fast = fast.next.next
            if slow == fast:   # 相遇于环中某点
                fast = pHead
                while(fast!=slow):   # 让两个指针分别从相遇点和链表头出发，两者都改为每次走一步，最终相遇于环入口
                    fast = fast.next
                    slow = slow.next
                return slow
        return None

27；反转链表

题目描述
输入一个链表，反转链表后，输出新链表的表头。

输入; {1,2,3}
输出：{3,2,1}

# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        if pHead == None or pHead.next ==None:
            return pHead
        pre = None
        cur = pHead
        while cur != None:
            tmp = cur.next   # 缓存cur的下一个元素
            cur.next = pre   #改变cur 的指针
            pre = cur      # 当前点成为新的上一个点
            cur = tmp   #当前点顺序推进到下一个点
            
        return  pre


28；合并两个排序的链表

题目描述
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

输入：{1,3,5},{2,4,6}
输出：{1,2,3,4,5,6}


参考答案：
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        if pHead1 == None and  pHead2 == None:
            return None
        if pHead1 == None:
            return pHead2
        if pHead2 == None:
            return pHead1
        p = pHead2.next
        q = pHead1
        front = pHead2
        if pHead1.val < pHead2.val:
            front = pHead1
            p = pHead1.next
            q = pHead2
        head = front
        while(p!=None and q!=None):   # p代表第一个元素值最小的那一行
            if q.val < p.val:
                tmp = q.next
                q.next = p      # 这里有点不好理解,因为我们是以p为基准的。
                front.next = q 
                front = q
                q = tmp
            else:
                front = front.next
                p = p.next
        if(q!=None):
            front.next = q   # p 已经排序完了，还余下一部分q
            
        return head


29；树的子结构
题目描述
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

输入：{8,8,#,9,#,2,#,5},{8,9,#,2}
输出：true

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    
    def __init__(self):
        self.subtree = False

    def check(self,A,B):
        if self.subtree==False:
            return None
        if B.left==None and B.right ==None:
            return None
        if B.left != None :
            if A.left!=None and B.left.val == A.left.val:
                self.check(A.left,B.left)
            else:
                self.subtree = False
        if B.right!=None:
            if A.right != None and B.right.val == A.right.val:
                self.check(A.right,B.right)
            else:
                self.subtree=False
            
    def PreOrder(self,Root):
        if self.subtree:
            return None
        if Root == None:
            return None
        if Root.val == self.target.val:   # 根节点相等的时候，再去check
            self.subtree = True
            self.check(Root,self.target)
        if Root.left != None:   # 往左遍历
            self.PreOrder(Root.left)
        if Root.right != None:    # 往右遍历
            self.PreOrder(Root.right)

    def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        if pRoot2 == None or pRoot1==None:
            return False
        self.target = pRoot2
        self.PreOrder(pRoot1)
        return self.subtree

30；二叉树的镜像
题目描述
操作给定的二叉树，将其变换为源二叉树的镜像。

比如：    源二叉树 
            8
           /  \
          6   10
         / \  / \
        5  7 9 11
        镜像二叉树
            8
           /  \
          10   6
         / \  / \
        11 9 7  5

参考答案：
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
# @param pRoot TreeNode类 
# @return TreeNode类
#
class Solution:
    def Mirror(self , pRoot ):
        # write code here
        if pRoot == None:
            return None
        pRoot.left,pRoot.right = pRoot.right,pRoot.left
        if pRoot.left != None:
            self.Mirror(pRoot.left)
        if pRoot.right != None:
            self.Mirror(pRoot.right)
        return pRoot

31；对称的二叉树
题目描述
请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

输入：{8,6,6,5,7,7,5}
输出：true


# 思路：首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同
# 左子树的右子树和右子树的左子树相同即可，采用递归
# 非递归也可，采用栈或队列存取各级子树根节点


# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def isSymmetrical(self, pRoot):
        # write code here
        if pRoot == None:
            return True
        return self.comRoot(pRoot.left, pRoot.right)
    
    def comRoot(self,left,right):
        if left == None and right == None:
            return True
        if left == None and right != None:
            return False
        if right == None:
            return False
        if left.val != right.val:
            return False
        return self.comRoot(left.left, right.right) and self.comRoot(left.right, right.left)


31；顺时针打印矩阵
题目描述
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

输入：[[1,2],[3,4]]
输出：[1,2,4,3]
参考答案：
# -*- coding:utf-8 -*-
class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        # write code here
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return []
        col_start = 0
        col_end = len(matrix[0]) - 1
        row_start = 0
        row_end = len(matrix) - 1
        ans = []
        while(col_start < col_end and row_start < row_end):
            for i in range(col_start,col_end):   # 当前行的最后一个元素，没有取！
                ans.append(matrix[row_start][i])
            for i in range(row_start,row_end):   # 当前列的最后一个元素，没有取！
                ans.append(matrix[i][col_end])
            for i in reversed(range(col_start+1,col_end+1)):  # 这里的写法要注意！ 取了当前行最后一个元素，到当前行第二个元素
                ans.append(matrix[row_end][i])
            for i in reversed(range(row_start+1,row_end+1)):  # 取了当前列最后一个元素，到当前列第二个元素
                ans.append(matrix[i][col_start])
            col_start += 1
            col_end -= 1
            row_start += 1
            row_end -= 1
        if col_start == col_end:   # 此时只有一行数据
            for i in range(row_start,row_end+1):
                ans.append(matrix[i][col_start])
        elif row_start == row_end: # 此时只有一列数据
            for i in range(col_start,col_end+1):
                ans.append(matrix[row_start][i])
        return ans

32；包含min函数的栈

题目描述
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 函数的时间复杂度都是 O(1).
push(value)：将元素 value压入栈中
pop()：弹出栈顶的元素
top() ：获得栈顶元素
min() ：获得栈中的最小元素。

示例:
输入:
["PSH-1","PSH2","MIN","TOP","POP","PSH1","TOP","MIN"]
输出:
-1,2,1,-1

解释如下:
"PSH-1":   将元素-1压入栈中，栈中元素为-1
”PSH2":    将元素2压入栈中，栈中元素为2, -1
"MIN"：    获取最小的元素 ==>输出-1
"TOP":      获得栈顶元素 ==>输出2
"POP":      弹出栈顶元素，即弹出2，栈中元素为-1
"PSH1"： 将元素1压入栈中，栈中元素为1，-1
"TOP":      获得栈顶元素 ==>输出1
"MIN"：    获取最小的元素 ==>输出-1


参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack = []
        self.minstack = []
    def push(self, node):
        # write code here
        self.stack.append(node)
        if len(self.minstack) == 0:
            self.minstack.append(node)
        elif node <= self.min():
            self.minstack.append(node)
    def pop(self):
        # write code here
        node = self.stack.pop()
        if node == self.min():
            self.minstack.pop()
    def top(self):
        # write code here
        return self.stack[-1]
    def min(self):
        # write code here
        return self.minstack[-1]

33；栈的压入、弹出序列
题目描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

输入：[1,2,3,4,5],[4,3,5,1,2]
输出：false

【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。
举例：
入栈1,2,3,4,5
出栈4,5,3,2,1
首先1入辅助栈，此时栈顶1≠4，继续入栈2
此时栈顶2≠4，继续入栈3
此时栈顶3≠4，继续入栈4
此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3
此时栈顶3≠5，继续入栈5
此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3
依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def IsPopOrder(self, pushV, popV):
        # write code here
        k = 0
        stack = []
        for num in popV:
            while(k<len(pushV) and (len(stack) == 0 or stack[-1] != num)):
                stack.append(pushV[k])
                k += 1
            if len(stack) > 0 and stack[-1] == num:
                stack.pop()
        if len(stack) != 0:
            return False
        else:
            return True


34；按之字形顺序打印二叉树

题目描述
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

输入：{8,6,10,5,7,9,11}
输出：[[8],[10,6],[5,7,9,11]]

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def Print(self, pRoot):
        # write code here
        if pRoot is None:
            return []
        self.q = [pRoot]
        ans = []
        row = 1
        while(len(self.q)!=0):
            size = len(self.q)
            l = []
            for i in range(0,size):
                front = self.q.pop(0)
                l.append(front.val)
                if front.left != None:
                    self.q.append(front.left)
                if front.right != None:
                    self.q.append(front.right)
            if row%2 == 1:
                ans.append(l[:])
            else:
                ans.append(l[::-1])
            row += 1
        return  ans


35；把二叉树打印成多行
题目描述
从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

输入：{8,6,10,5,7,9,11}
输出：[[8],[6,10],[5,7,9,11]]

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回二维列表[[1,2],[4,5]]
    def Print(self, pRoot):
        # write code here
        if pRoot == None:
            return []
        self.q = [pRoot]
        ans = []
        row = 1
        while(len(self.q)!=0):
            size = len(self.q)
            l = []
            for i in range(0,size):
                front = self.q.pop(0)
                l.append(front.val)
                if front.left != None:
                    self.q.append(front.left)
                if front.right != None:
                    self.q.append(front.right)
            ans.append(l[:])
            row += 1
        return ans


36：从上往下打印二叉树

题目描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。

输入：{5,4,#,3,#,2,#,1}
输出：[5,4,3,2,1]

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回从上到下每个节点值列表，例：[1,2,3]
    def PrintFromTopToBottom(self, root):
        # write code here
        from Queue import deque
        ans = []
        queue = deque()
        if root is  None:
            return ans
        queue.append(root)
        while(len(queue)!=0):
            x = queue.popleft()
            ans.append(x.val)
            if x.left is not None:
                queue.append(x.left)
            if x.right is not None:
                queue.append(x.right)
        return ans


37；二叉搜索树的后序遍历序列
题目描述
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）

输入：[4,8,6,12,16,14,10]
输出：true

注：二叉查找树（Binary Search Tree：BST），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def VerifySquenceOfBST(self, sequence):
        # write code here
        if len(sequence) == 0:
            return False
        return self.check(sequence,0,len(sequence)-1)
    def check(self,arr,start,end):
        if start >= end:  #直到start >= end，还没出现false，可以返回end
            return True
        root = arr[end]
        end -= 1
        end_mark = end   #标记本次运行中的end
        while (end>=0 and arr[end] > root):
            end -= 1
        mid = end + 1
        for i in range(start,mid):  # 注意这里是start,不能写成 0 
            if arr[i] > root:
                return False
        return self.check(arr,start,mid-1) and self.check(arr,mid,end_mark)




38；二叉树中和为某一值的路径

题目描述
输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

输入：{10,5,12,4,7},22
输出：[[10,5,7],[10,12]]

输入：{10,5,12,4,7},15
输出：[]
考点：深度优先遍历

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        # write code here
        if root is None:
            return []
        self.ans = []
        def Find(temp,root):
            temp.append(root.val)
            if root.left == None and root.right == None:  #没有后序子节点了
                if sum(temp) == expectNumber:
                    self.ans.append(temp[:])  # 注意这里的写法
            else:
                if sum(temp) > expectNumber:
                    temp.pop()
                    return   # 结束本条路径,换一条路径
                if root.left is not None:
                    Find(temp[:],root.left)
                if root.right is not None:
                    Find(temp,root.right)
        Find([],root)
        return self.ans


39；复杂链表的复制
题目描述
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

参考答案：
# -*- coding:utf-8 -*-
# class RandomListNode:
#     def __init__(self, x):
#         self.label = x
#         self.next = None
#         self.random = None
class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):
        # write code here
        if pHead is None:
            return None
        hashset = dict()
        p = pHead
        helpHead = RandomListNode(-1)
        q = helpHead
        while(p is not None):
            newNode = RandomListNode(p.label)
            hashset[p] = newNode  #字典里面key存的是p这个点
            q.next = newNode
            q = q.next
            p = p.next
        p = pHead
        q = helpHead.next
        while(p is not None):
            q.random = hashset.get(p.random, None)   #这里可以根据p的 random 这个属性，获取对应的key的属性值！
            p = p.next
            q = q.next
        return helpHead.next




40；二叉搜索树与双向链表

题目描述
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

注：双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。

参考答案：
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

#
# 
# @param pRootOfTree TreeNode类 
# @return TreeNode类
#
class Solution:
    def Convert(self , pRootOfTree ):
        # write code here
        if not pRootOfTree:
            return 
        self.arr = []
        self.midTraversal(pRootOfTree)
        for i,v in enumerate(self.arr[:-1]):   #截止到倒数第二个点
            v.right = self.arr[i+1]
            self.arr[i+1].left = v
        return self.arr[0]
    
    def midTraversal(self,root):
        if not root:return
        self.midTraversal(root.left)
        self.arr.append(root)
        self.midTraversal(root.right)
        





41；序列化二叉树
描述
请实现两个函数，分别用来序列化和反序列化二叉树

二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。

二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。

例如，我们可以把一个只有根节点为1的二叉树序列化为"1,"，然后通过自己的函数来解析回这个二叉树

示例：
输入：{8,6,10,5,7,9,11}
输出：{8,6,10,5,7,9,11}

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def Serialize(self, root):
        # write code here
        if not root: return '#'
        # 先序遍历
        return str(root.val) + ',' + self.Serialize(root.left) + ',' + self.Serialize(root.right)
    def Deserialize(self, s):
        # write code here
        root,index = self.deserialize(s.split(","),0)
        return root
    def deserialize(self,s,index):
        if s[index] == '#':
            return None, index+1
        root = TreeNode(int(s[index]))
        index += 1
        root.left, index = self.deserialize(s, index)   # 递归 + 先序
        root.right, index = self.deserialize(s,index)
        return root, index

42；字符串的排列（难题）
描述
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入描述：
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

输入："ab"
输出：["ab","ba"]

参考答案：
class Solution:
    def Permutation(self, ss):
        # write code here
        if len(ss) == 0:
            return []
        ss = sorted(list(ss))
        used = [False] * len(ss)
        self.ans = []
        def dfs(temp,used):
            # 走完所有可能，记录排列
            if len(temp) == len(ss):
                self.ans.append("".join(temp))  #所有字母全都在temp里面了，结束当前方法
                return   # 返回上一步
            # 遍历整个序列，尝试每一种可能。
            for i in range(len(ss)):
                # 是否走过  used[i]  等于 True,则表示已经走过
                if (i>0 and ss[i] == ss[i-1] and used[i-1]==False) or used[i]:   # 这里第一个括号里面的条件，很难想明白。
                    continue
                temp.append(ss[i])
                used[i] = True
                dfs(temp,used)   # 在这一个DFS里面，i 一直是used的状态。
                temp.pop()   # 当前节点遍历完了，返回到上一节点。   # append, pop  这里用到了栈
                # 走完最后一步，后退一步
                used[i] = False
        dfs([],used)
        return self.ans




43；数组中出现次数超过一半的数字
描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1<=数组长度<=50000

输入：[1,2,3,2,2,2,5,4,2]
输出：2

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        # write code here
        res = {}
        for item in numbers:
            res[item] = res.get(item,0) + 1
        res = sorted(res.items(), key=lambda x:x[1], reverse=True)
        ans = res[0][0]
        return ans

44；最小的K个数
描述
给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K>数组的长度，那么返回一个空的数组

输入：[4,5,1,6,2,7,3,8],4 
输出：[1,2,3,4]

# -*- coding:utf-8 -*-
class Solution:
    def GetLeastNumbers_Solution(self, tinput, k):
        # write code here
        if k > len(tinput):
            return []
        res = sorted(tinput, reverse=False)
        try:
            ans = res[:k]
            
        except:
            ans = []
        return ans


45；数据流中的中位数
描述
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

参考答案：
# -*- coding:utf-8 -*-
class Heap:
    def __init__(self,cmp_f):   #cmp_f 堆排序方式
        self.cmp = cmp_f
        self.heap = []
    def siftDown(self,i):
        target= i
        left = 2*i + 1
        right = 2*i + 2
        if left < self.size() and self.cmp(self.heap[left],self.heap[target]):  
            # 假设这里现在是最大堆，左子节点大于当前节点，当前节点下沉到左子节点
            target = left
        if right < self.size() and self.cmp(self.heap[right],self.heap[target]):
            target = right
        if target != i:
            self.heap[target],self.heap[i] = self.heap[i],self.heap[target]  # 父子节点互换
            self.siftDown(target)   # 递归调用，直到都满足堆约束
    def size(self,):
        return len(self.heap)
    def pop(self,):
        if self.size() ==0:
            return None
        self.heap[0],self.heap[-1] = self.heap[-1],self.heap[0]  # 堆的最后一个元素和堆顶元素互换位置
        elem = self.heap.pop()  # 取出堆顶元素
        self.siftDown(0)   # 通过下沉方法，恢复堆顺序
        return elem
    def insert(self,num):
        self.heap.append(num)
        i = self.size() - 1   # 新加入堆的元素
        parent = (i-1)>>1   # 新加入元素的父节点
        while(i>0 and self.cmp(self.heap[i],self.heap[parent])):   # 假设self.cmp这里是取最大值，那么这里用的是 上浮 的方法；当前节点比其父节点值更大，上浮。
            self.heap[parent],self.heap[i] = self.heap[i],self.heap[parent]  # 父子节点互换位置
            i = parent
            parent = (i-1)>>1   #这两部索引更新
        
    def top(self,):
        return self.heap[0]
        
        
class Solution:
    def __init__(self,):
        self.maxHeap = Heap(lambda x,y:x>y)   #最大堆
        self.minHeap = Heap(lambda x,y:x<y)   #最小堆
    def Insert(self, num):
        # write code here
        if self.maxHeap.size() == self.minHeap.size():
                self.minHeap.insert(num)
                self.maxHeap.insert(self.minHeap.pop())   # 排序后的 前半部分数据，都在maxHeap里面
        else:
                self.maxHeap.insert(num)
                self.minHeap.insert(self.maxHeap.pop())   # 排序后的 后半部分数据，都在minHeap里面
    def GetMedian(self,n=None):
        # write code here
        if self.maxHeap.size() == self.minHeap.size():
            return (self.maxHeap.top()+self.minHeap.top())/2.0
        else:
            return self.maxHeap.top()*1.0


46；连续子数组的最大和
描述
输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        # write code here
        max_A = array[0]
        for i in range(1,len(array)):
            array[i] += array[i-1] if array[i-1]>0 else 0
            max_A = max(max_A, array[i])
        return max_A

47；整数中1出现的次数（从1到n整数中1出现的次数）

描述
输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数
例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        # write code here
        m = 1
        count = 0
        while(m<=n):
            a = n//m
            b = n%m
            count += (a+8)//10 * m
            if a % 10 == 1:
                count += (b+1)
            m *= 10
        return count


48；把数组排成最小的数
描述
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

示例1
输入：[3,32,321]
返回值："321323"

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def PrintMinNumber(self, numbers):
        # write code here
        def cmp(a,b):
            num1 = int(str(a) + str(b))
            num2 = int(str(b) + str(a))
            if num1 < num2:
                return -1
            elif num1 > num2:
                return 1
            else:
                return 0
        numbers.sort(cmp)
        return "".join(str(num) for num in numbers)

49；丑数
描述
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

# -*- coding:utf-8 -*-
class Solution:
    def GetUglyNumber_Solution(self, index):
        # write code here
        if index <= 0:
            return 0
        dp = [1]
        t2 = t3 = t5 = 0
        for i in range(index):
            ugly = min(min(dp[t2]*2,dp[t3]*3),dp[t5]*5)
            if ugly == dp[t2]*2:
                t2 +=1
            if ugly == dp[t3]*3:
                t3 += 1
            if ugly == dp[t5]*5:
                t5 += 1
            dp.append(ugly)
        return dp[index-1]

50；第一个只出现一次的字符

描述
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

输入："google"
输出：4

参考答案：

# -*- coding:utf-8 -*-
class Solution:
    def FirstNotRepeatingChar(self, s):
        # write code here
        count = {}
        for i in s:
            count[i] = count.get(i,0) + 1
        for i in range(len(s)):
            if count[s[i]] == 1:
                return i
        return -1

51；字符流中第一个不重复的字符

描述
请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
后台会用以下方式调用Insert 和 FirstAppearingOnce 函数
string caseout = "";
1.读入测试用例字符串casein
2.如果对应语言有Init()函数的话，执行Init() 函数
3.循环遍历字符串里的每一个字符ch {
Insert(ch);
caseout += FirstAppearingOnce()
}
2. 输出caseout，进行比较。

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    # 返回对应char
    def __init__(self):
        self.d = {}
        self.count = 0
    def FirstAppearingOnce(self):
        # write code here
        ans = float("inf")
        cha = "#"
        for k,v in self.d.items():
            if v != -1 and v < ans:
                cha = k
                ans = v
        return cha
    def Insert(self, char):
        # write code here
        if char not in self.d:
            self.d[char] = self.count
        else:
            self.d[char] = -1
        self.count += 1

52；数组中的逆序对

描述
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

对于%50%的数据,size<=10^4
 
对于%75%的数据,size<=10^5
 
对于%100%的数据,size<=2*10^5

输入描述：
题目保证输入的数组中没有的相同的数字

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def InversePairs(self, data):
        # write code here
        length = len(data)
        if length <= 1:
            return 0
        copy = data[:]  # 占位   # 靠，原来是这里被坑了！
        count = self.InversePairsCore(data,copy,0,length-1)
        return count % 1000000007
    
    def InversePairsCore(self,data,copy,start,end):
        if start == end:
            copy[start] = data[start]
            return 0
        length = (end - start) / 2 
        left = self.InversePairsCore(copy,data,start,start+length)
        right = self.InversePairsCore(copy,data,start+length+1,end)
        i = start + length  #从右往左比
        j = end
        indexcopy = end
        count = 0
        while (i>=start and j >= start+length+1):
            if(data[i] > data[j]):
                copy[indexcopy] = data[i]
                indexcopy -=1
                i -=1
                count = count + j - (start+length)
            else:   #右边大于左边，这一次比较没有逆序对
                copy[indexcopy] = data[j]
                indexcopy -=1
                j -= 1
        # 同时满足上面两者的已经走完了，可能还余下左边数组，或者余下右边数组
        while i >= start:
            copy[indexcopy] = data[i]
            indexcopy -= 1
            i -= 1
        while j >= start + length +1:
            copy[indexcopy] = data[j]   # 现在 copy 已经成为部分排序后的data了
            indexcopy -= 1
            j -= 1
        return  left + right + count

53；两个链表的第一个公共结点

描述
输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        # write code here
        len1 = self.findListLength(pHead1)
        len2 = self.findListLength(pHead2)
        if len1 > len2:
            pHead1 = self.walkStep(pHead1, len1-len2)
        else:
            pHead2 = self.walkStep(pHead2, len2-len1)
        while(pHead1 != None):
            if pHead1 == pHead2:
                return pHead1
            pHead1 = pHead1.next
            pHead2 = pHead2.next
        return pHead1
        
    def findListLength(self, pHead1):
        if pHead1 == None:
            return 0
        sum = 1
        while(pHead1.next != None):
            sum += 1
            pHead1 = pHead1.next
        return sum
    
    def walkStep(self,pHead1, step):
        while(step>0):
            pHead1 = pHead1.next
            step -= 1
        return pHead1


54；二叉搜索树的第k个结点

描述
给定一棵二叉搜索树，请找出其中的第k小的TreeNode结点。

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回对应节点TreeNode
    def KthNode(self, pRoot, k):
        # write code here
        if k == 0 or pRoot is None:
            return None
        stack = []
        cur = pRoot
        while(True):
            while(cur is not None):
                stack.append(cur)
                cur = cur.left
            if len(stack) == 0:
                break
            cur = stack.pop()
            k -= 1
            if k==0:
                break
            cur = cur.right
        return cur


55；二叉树的深度

描述
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def TreeDepth(self, pRoot):
        # write code here
        if pRoot is None:
            return 0
        self.depth = 1
        def preOrder(root,depth):
            if root is None:
                return 
            if root.left is None and root.right is None:
                self.depth = max(self.depth,depth)  #快退出函数时，更新depth
                return 
            preOrder(root.left, depth+1)
            preOrder(root.right, depth+1)
        preOrder(pRoot, 1)
        return self.depth

56；平衡二叉树
描述
输入一棵二叉树，判断该二叉树是否是平衡二叉树。
在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树
平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

参考答案：
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def IsBalanced_Solution(self, pRoot):
        # write code here
        return self.getDepth(pRoot) != -1
    
    def getDepth(self, root):
        if root == None: return 0
        left = self.getDepth(root.left)
        if left == -1: return -1
        right = self.getDepth(root.right)
        if right == -1:return -1
        return -1 if abs(left - right) > 1  else 1 + max(left,right)

57；数组中只出现一次的两个数字

描述
一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
示例1
输入：
[1,4,1,6]
返回值：
[4,6]
说明：
返回的结果中较小的数排在前面  

参考答案：
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
# @param array int整型一维数组 
# @return int整型一维数组
class Solution:
    def FindNumsAppearOnce(self , array ):
        # write code here
        d = {}
        for i in array:
            d[i] = d.get(i,0) + 1
        ans = []
        for i in range(len(array)):
            if d[array[i]] == 1:
                ans.append(array[i])
                ans.sort()
        return ans 

58；和为S的连续正数序列
描述
小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
返回值描述：
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
示例1
输入：
9
返回值：
[[2,3,4],[4,5]]

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def FindContinuousSequence(self, tsum):
        # write code here
        result = []
        plow = 1
        phigh= 2
        while(phigh >  plow):
            cur = (phigh + plow) * (phigh - plow +1) / 2 # 等差数列求和 Sn=n(a1+an)/2
            if cur == tsum:
                List = []
                i = plow
                while i <= phigh:
                    List.append(i)
                    i += 1
                result.append(List)
                plow += 1
            elif cur < tsum:
                phigh += 1
            else:
                plow += 1
        return result

59；和为S的两个数字
描述
输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
返回值描述：
对应每个测试案例，输出两个数，小的先输出。
示例1
输入：
[1,2,4,7,11,15],15
返回值：
[4,11]

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def FindNumbersWithSum(self, array, tsum):
        # write code here
        ret = []
        if len(array) == 0:
            return ret
        tmp = 10**10
        i,j = 0,len(array)
        while i < j and i != j:
            if array[i] + array[j-1] == tsum:
                if array[i] * array[j-1] < tmp:
                    tmp = array[i] * array[j-1]
                    ret = [array[i],array[j-1]]
                i +=1
                j -=1
            elif array[i] + array[j-1] < tsum:
                i +=1
            else:
                j -=1
        return ret

60；翻转单词序列
描述
牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
示例1
输入：
"nowcoder. a am I"
返回值：
"I am a nowcoder."

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def ReverseSentence(self, s):
        # write code here
        s = s.split(" ")
        ans = s[::-1]
        ans = " ".join(i for i in ans)
        return ans

61；左旋转字符串
描述
汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
示例1
输入：
"abcXYZdef",3
返回值：
"XYZdefabc"

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def LeftRotateString(self, s, n):
        # write code here
        str1 = s[n:]
        str2 = s[:n]
        ans = str1 + str2
        return ans

62；滑动窗口的最大值
描述
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
窗口大于数组长度的时候，返回空
示例1
输入：
[2,3,4,2,6,2,5,1],3
返回值：
[4,4,6,6,6,5]

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def maxInWindows(self, num, size):
        # write code here
        from Queue import deque
        queue = deque()
        res = []
        for i in range(len(num)):
            while(len(queue) and num[queue[-1]] < num[i]):
                queue.pop()
            while(len(queue) and i - queue[0] + 1 > size):
                queue.popleft()
            queue.append(i)
            if size and i -size + 1 >= 0:
                res.append(num[queue[0]])
        return res

63；扑克牌顺子
描述
现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。
有如下规则：
1. A为1，J为11，Q为12，K为13，A不能视为14
2. 大、小王为 0，0可以看作任意牌
3. 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。
例如：给出数据[6,0,2,0,4]
中间的两个0一个看作3，一个看作5 。即：[6,3,2,5,4]
这样这五张牌在[2,6]区间连续，输出true
数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]

示例1
输入：
[6,0,2,0,4]
返回值：
true
示例2
输入：
[0,3,2,6,4]
返回值：
true
示例3
输入：
[1,0,0,1,0]
返回值：
false
示例4
输入：
[13,12,11,0,1]
返回值：
false

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def IsContinuous(self, numbers):
        # write code here
        if len(numbers) < 5:
            return False
        d = [0] * 14
        MAX = -1
        MIN = 14
        for i in range(len(numbers)):
            d[numbers[i]] += 1
            if numbers[i] == 0:
                continue   # 跳过本次循环后续步骤
            if d[numbers[i]] > 1:   # 有重复数字
                return False  
            MAX = max(MAX, numbers[i])
            MIN = min(MIN, numbers[i])
        if MAX - MIN < 5:
            return True
        else:
            return False

64；孩子们的游戏(圆圈中最后剩下的数)

描述
每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

如果没有小朋友，请返回-1
示例1
输入：
5,3
返回值：
3

参考答案：
"""
递推公式
f[1]=0;
f[i]=(f[i-1]+m)%i;  (i>1)
有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。 因为实际生活中编号总是从1开始，我们输出f[n]+1。
"""
# -*- coding:utf-8 -*-
class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        if  n == 0:
            return -1
        if n == 1:
            return 0
        f = 0
        for i in range(2,n+1):
            f = (f+m)%i 
        return f

65；不用加减乘除做加法

描述
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

# -*- coding:utf-8 -*-
class Solution:
    def Add(self, num1, num2):
        # write code here
        if not num1: return num2
        if not num2: return num1
        while num2:# 加法是异或，进位是与<<1 + 越界检查
            tmp = (num1^num2)&0xffffffff
            num2 = num2&0xffffffff
            num2 = ((num1&num2)<<1)
            num1 = tmp
        return num1 if num1<=0x7fffffff else ~(num1^0xffffffff)

66；构建乘积数组

描述
给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）
对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。
示例1
输入：
[1,2,3,4,5]
返回值：
[120,60,40,30,24]

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def multiply(self, A):
        # write code here
        ans = []
        for i in range(0,len(A)):
            B = A[:]  #学到的赋值列表的方法
            B.pop(i)
            C = 1 
            for i in B:
                C  = C * i 
            ans.append(C)
        return ans

67；把字符串转换成整数

描述
将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0
输入描述：
输入一个字符串,包括数字字母符号,可以为空
返回值描述：
如果是合法的数值表达则返回该数字，否则返回0

示例1
输入：
"+2147483647"
返回值：
2147483647
示例2
输入：
"1a33"
返回值：
0

参考答案：
# -*- coding:utf-8 -*-
class Solution:
    def StrToInt(self, s):
        # write code here
        ans = ''
        sign = 1
        for i in s:
            if i in '0123456789':
                ans += i 
            if i == '-':
                sign = -1
            if i not in '+-0123456789':
                return 0
        if ans == '':
            return 0
        return sign * int(ans)

68；正则表达式匹配

描述
请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

太难了，有空再想！


69；表示数值的字符串

描述
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
示例1
输入：
"123.45e+6"
返回值：
true
示例2
输入：
"1.2.3"
返回值：
false

python3  float~











